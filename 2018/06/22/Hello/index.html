<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Hello | SIlent</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Hello</h1><a id="logo" href="/.">SIlent</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Hello</h1><div class="post-meta">Jun 22, 2018</div><div class="post-content"><p>这两天用C/C++实现了一下线性代数库的Python模块，大部分操作已经封装完成，剩下的慢慢补坑吧= =</p>
<p>关于线性代数库的一些算法实现，可以参考我的前一篇文章从头开始实现一个线性代数库：算法实现篇。现在主要总结一下如何用C/C++编写Python模块，代码地址<a href="https://github.com/netcan/LinAlg/tree/master/linalg.module。" target="_blank" rel="noopener">https://github.com/netcan/LinAlg/tree/master/linalg.module。</a></p>
<p>先来看看效果：</p>
<pre><code>In [1]: ls
linalg.cpython-36m-darwin.so*
In [2]: import linalg
In [3]: m = linalg.Matrix([
   ...:     [43, 63, 57, 35],
   ...:     [63, 26, 32, 35],
   ...:     [57, 32, 78, 76],
   ...:     [35, 35, 76, 25],
   ...: ])
In [4]: m.Jacobi()
Out[4]: C(-19.248723 33.225382 197.775875 -39.752533)
In [5]: m.det()
Out[5]: 5028170.999999999
</code></pre><p>编写模块最麻烦的部分应该是引用计数了，如果能够妥善处理，将会事半功倍，我因为这个问题debug好久了。紧接着就是异常处理了。主要参考资料还是官方文档：</p>
<pre><code>Extending Python with C or C++
Defining Extension Types: Tutorial
Defining Extension Types: Assorted Topics
Building C and C++ Extensions
</code></pre><p>定义模块</p>
<p>首先定义一个名为linalg的模块，其下有两个类：linalg.Vector和linalg.Matrix。</p>
<pre><code>static PyModuleDef linalgmodule = {
    PyModuleDef_HEAD_INIT,
    &quot;linalg&quot;,   /* name of module */
    NULL,        /* module documentation, may be NULL */
    -1,            /* size of per-interpreter state of the module,
                 or -1 if the module keeps state in global variables. */
};
</code></pre><p>如果需要定义一些模块级方法，需要在定义linalgmodule的时候指定m_methods，这里不需要这类方法，就省略了。</p>
<p>接下来初始化模块，定义名为PyInit_linalg的函数：</p>
<pre><code>PyMODINIT_FUNC
PyInit_linalg(void) {
    PyObject *m;
    m = PyModule_Create(&amp;linalgmodule);
    if (m == NULL) return NULL;
    // 添加Vector/Matrix类
    if (PyType_Ready(&amp;PyVectorType) &lt; 0) return NULL;
    if (PyType_Ready(&amp;PyMatrixType) &lt; 0) return NULL;
    Py_INCREF(&amp;PyVectorType);
    Py_INCREF(&amp;PyMatrixType);
    PyModule_AddObject(m, &quot;Vector&quot;, (PyObject*)&amp;PyVectorType);
    PyModule_AddObject(m, &quot;Matrix&quot;, (PyObject*)&amp;PyMatrixType);
    return m;
}
</code></pre><p>可以看到在初始化模块的时候，添加了linalg.Vector和linalg.Matrix两个类。接下来定义这两个类，以及类方法。<br>定义linalg.Vector类</p>
<p>由于linalg.Matrix类和linalg.Vector类定义的方法基本相同，这里只总结一下linalg.Vector类的定义以及实现。</p>
<p>首先定义VectorObject对象类：</p>
<pre><code>typedef struct {
    PyObject_HEAD;
    Vector ob_vector; // 需要封装的成员
} PyVectorObject;
</code></pre><p>接着是VectorType类的定义：</p>
<pre><code>static PyTypeObject PyVectorType = {
    PyObject_HEAD_INIT(NULL)
    .tp_name = &quot;linalg.Vector&quot;, // 模块类名
    .tp_doc = &quot;Vector objects&quot;, // doc描述
    .tp_basicsize = sizeof(PyVectorObject), // 对象大小
    .tp_itemsize = 0,
    .tp_dealloc = (destructor) PyLinAlg_dealloc, // 析构函数
    .tp_new = PyType_GenericNew, // 构造函数
    .tp_init = (initproc) PyVector_init, // 初始化函数
    .tp_members = PyVector_members, // 类成员
    .tp_methods = PyVector_methods, // 类方法
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_str = (reprfunc)PyVector_str, // str(obj), print用
    .tp_repr = (reprfunc)PyVector_str,
    .tp_as_sequence = &amp;PyVectorSeq_methods, // 一些序列类方法，例如vec[i]
    .tp_as_number = &amp;PyVectorNum_methods, // 基本运算方法，例如vecA + vecB
};
</code></pre><p>先来看看linalg.Vector的析构函数，若不是单例模式，所有类都需要这个函数在引用计数为0的时候来释放对象：</p>
<pre><code>static void
PyLinAlg_dealloc(PyObject *self) {
    Py_TYPE(self)-&gt;tp_free((PyObject *)self);
}
</code></pre><p>构造函数使用默认的PyType_GenericNew就好，初始化一个Vector类，在C++接口中是这样的：</p>
<pre><code>Vector v({16,22,32,44});
v.show();
</code></pre><p>现在用Python模块方式进行初始化，为了简单起见，这里只支持列表类型初始化，即：</p>
<pre><code>In [6]: v = linalg.Vector([1,2,3,4])
In [7]: v
Out[7]: C(1.000000 2.000000 3.000000 4.000000)
</code></pre><p>初始化函数如下：</p>
<pre><code>static int
PyVector_init(PyVectorObject *self, PyObject *args, PyObject *kwds) {
    PyObject *pList, *pItem;
    if (!PyArg_ParseTuple(args, &quot;O!&quot;, &amp;PyList_Type, &amp;pList)) { // 初始化参数必须为列表
        PyErr_SetString(PyExc_TypeError, &quot;parameter must be a list.&quot;);
        return -1;
    } 
    Py_ssize_t n = PyList_Size(pList); // 获取列表长度
    if(n &lt;= 0) {
        PyErr_SetString(PyExc_TypeError, &quot;size of list must be greater than 0&quot;);
        return -1;
    }
    vector&lt;double&gt; data;
    for(Py_ssize_t i = 0; i &lt; n; ++i) {
        pItem = PyList_GetItem(pList, i);
        if(! isNumber(pItem))  return -1; // 列表内的元素必须为数字
        else data.push_back(getNumber(pItem));
    }
    self-&gt;ob_vector = Vector(data); // 存入封装Vector的VectorObject类型中
    return 0;
}
</code></pre><p>而对于类支持的方法，需要定义一个数组PyVector_methods说明，比如linalg.Vector类支持T(), copy()方法，那么：</p>
<pre><code>static PyMethodDef PyVector_methods[] = {
    {&quot;T&quot;, (PyCFunction)PyVector_T, METH_NOARGS, &quot;change vector type&quot;},
    {&quot;copy&quot;, (PyCFunction)PyVector_Copy, METH_NOARGS, &quot;deep copy of vector&quot;},
    {NULL}  /* Sentinel */
};
</code></pre><p>然后实现PyVector_T()和PyVector_Copy即可。</p>
<p>而对于一些magic方法，例如<strong>add</strong>, <strong>getitem</strong>等等，需要在PyTypeObject的.tp_as_number和.tp_as_sequence数组中指明。<br>引用计数导致的BUG</p>
<p>之前因为返回对象的引用计数导致了非常麻烦的BUG，这里贴出来一下：</p>
<pre><code>static PyObject *
PyVector_imul(PyVectorObject *self, PyObject *arg) {
    if(!arg || ! isNumber(arg)) return NULL;
    Py_XINCREF(self); // 不加这个会崩溃...因为返回的对象没有被接收会被释放掉
    self-&gt;ob_vector *= getNumber(arg);
    return (PyObject*)self;
}
</code></pre><p>这里定义了一下<em>=类方法，当执行v </em>= 5等语句，可能导致崩溃，需要增加引用计数来获得所有权，因为操作的对象是borrowed references的，那么返回的时候由于没有被其他对象引用，将被释放，而后来要是有对象申请空间也用到这块内存的话，就会出现异常。</p>
<p>官方文档是这么说明的，对于PyNumber_InPlaceAdd这类方法应该返回的是新引用，而不是borrowed references。</p>
<pre><code>PyObject PyNumber_InPlaceAdd(PyObject o1, PyObject *o2)
Return value: New reference.
Returns the result of adding o1 and o2, or NULL on failure. The operation is done in-place when o1 supports it. This is the equivalent of the Python statement o1 += o2.
</code></pre><p>在StackOverflow上有这么一个回答：<a href="https://stackoverflow.com/questions/11897597/implementing-nb-inplace-add-results-in-returning-a-read-only-buffer-object" target="_blank" rel="noopener">https://stackoverflow.com/questions/11897597/implementing-nb-inplace-add-results-in-returning-a-read-only-buffer-object</a></p>
<pre><code>According to the documentation, the inplace add operation for an object returns a new reference.
By returning self directly without calling Py_INCREF on it, your object will be freed while it is still referenced. If some other object is allocated the same piece of memory, those references would now give you the new object.
</code></pre><p>编译、链接模块</p>
<p>掌握了如何定义模块、类，剩下的就简单了，最后是通过编写setup.py来生成模块，如下：</p>
<pre><code>from distutils.core import setup, Extension
linalgmodule = Extension(&apos;linalg&apos;,
        extra_compile_args = [&apos;-std=c++14&apos;],
        sources = [&apos;src/linalgmodule.cpp&apos;],
        include_dirs = [&apos;include&apos;],
        libraries = [&apos;linalg&apos;],
        )
setup (name = &apos;linalg&apos;,
        version = &apos;0.1&apos;,
        author = &apos;netcan&apos;,
        author_email = &apos;netcan1996@gmail.com&apos;,
        description = &apos;A Linear Algebra library for studying by netcan&apos;,
        ext_modules = [linalgmodule],
        )
</code></pre><p>编译的时候，通过如下编译，</p>
<pre><code>python setup.py build
</code></pre><p>可能会报错，例如找不到std::move，这时候需要指定标准头文件的位置了：</p>
<pre><code>CFLAGS=&apos;-I/Library/Developer/CommandLineTools/usr/include/c++/v1/&apos; python setup.py build
</code></pre></div><div class="tags"></div><div class="post-nav"><a class="next" href="/2018/06/22/hello-world/">Hello World</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/22/Hello/">Hello</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/22/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">SIlent.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>